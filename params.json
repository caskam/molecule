{
  "name": "Molecule",
  "tagline": "A Rack inspired web micro-framework for easy and fun Java Web Development",
  "body": "## Quick Start\r\n\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) throws IOException {\r\n        WebServer server = WebServer.create();\r\n        server.start((request, response) -> response.done(\"Hello, World\"));\r\n    }\r\n}\r\n```\r\n\r\nAccess your application at:\r\n\r\n`http://localhost:8080`\r\n\r\n## About\r\n\r\nMolecule is a rack inspired micro web framework for Java, with minimal dependencies. It is fast, small, \r\neasy to use, easy to learn and easy to extend.\r\n\r\nMolecule is great for building micro services or regular web applications. It is designed around simplicity,\r\ntestability and freedom of choice. It's more a library than a framework really.\r\n\r\nMolecule is small, it weights less than 140k, and will stay as lean as possible. It is pluggable through the concept\r\nof rack middlewares and offers some out-of-the box integrations. You're free to use the built-in options \r\nor provide your own implementations. \r\n\r\nMolecule requires Java 8. It runs an embedded web-server powered by [Simple](http://simpleframework.org). Both are fully asynchronous and non-blocking, which means they can scale to very high loads.\r\n\r\nHave fun!\r\n\r\n## Download \r\n\r\nYou can get the latest release version from Maven Central:\r\n\r\n```xml\r\n<dependency>\r\n      <groupId>com.vtence.molecule</groupId>\r\n      <artifactId>molecule</artifactId>\r\n      <version>0.10</version>\r\n</dependency>\r\n```\r\n \r\nTo use the default web server, you also need to add [Simple](http://www.simpleframework.org) as a dependency:\r\n\r\n```xml\r\n<dependency>\r\n      <groupId>org.simpleframework</groupId>\r\n      <artifactId>simple-http</artifactId>\r\n      <version>6.0.1</version>\r\n</dependency>\r\n```\r\n\r\n## Want to start with some code?\r\n\r\nTry out the following examples:\r\n\r\n* [Hello World](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/helloworld/HelloWorldExample.java)\r\n* [Rendering HTML](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/simple/SimpleExample.java)\r\n* [Dynamic Routes](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/routing/RoutingExample.java)\r\n* [Static Files](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/files/StaticFilesExample.java)\r\n* [REST](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/rest/RESTExample.java)\r\n* [Asynchronous Processing](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/async/AsyncExample.java)\r\n* [Cookies](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/cookies/CookiesExample.java)\r\n* [Flash](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/flash/FlashExample.java)\r\n* [Locale Negotiation](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/locale/LocaleNegotiationExample.java)\r\n* [Multipart Forms](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/multipart/MultipartExample.java)\r\n* [View Templates and Layout](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/templating/TemplatingAndLayoutExample.java)\r\n* [HTTP Sessions](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/session/SessionExample.java)\r\n* [Multiple Applications](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/multiapps/MultiAppsExample.java)\r\n* [Filters](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/filtering/FilteringExample.java)\r\n* [Creating a Custom Middleware](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/middleware/CustomMiddlewareExample.java)\r\n* [Caching and Compression](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/performance/CachingAndCompressionExample.java)\r\n* [SSL](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/ssl/SSLExample.java)\r\n* [Basic Authentication](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/auth/BasicAuthExample.java)\r\n* [A Sample Application](https://github.com/testinfected/simple-petstore/blob/master/webapp/src/main/java/org/testinfected/petstore/PetStore.java)\r\n\r\n## Getting Started\r\n\r\nFirst thing first, you need a server to run your app:\r\n\r\n```java\r\nWebServer server = WebServer.create();\r\n```\r\n\r\nThis will set the default web server, which is powered by [Simple](http://www.simpleframework.org), \r\nto run locally on port 8080.\r\n\r\nTo start the server, give it an app:\r\n\r\n```java\r\nserver.start((request, response) -> response.done(\"Hello, World!\"));\r\n```\r\n\r\nTo stop the server, call the _stop_ method:\r\n\r\n```java\r\nserver.stop()\r\n```\r\n\r\nYou can optionally specify the interface and port to bound to when creating the server, e.g. if you want to make your server globally available:\r\n\r\n```java\r\nWebServer server = WebServer.create(\"0.0.0.0\", 8088);\r\n```\r\n\r\n## Asynchronous Processing\r\n\r\nMolecule uses [Simple](http://www.simpleframework.org) as a default webserver.\r\nBoth are fully asynchronous and non-blocking. This allows the server to scale to very high loads and handle as many concurrent connections as possible, even when depending on a high latency external resource.\r\n         \r\nWhat this means is you can serve your response content from a thread separate to the original servicing thread. For instance your application \r\nmight need to wait for some remote process that takes some time to complete, such as an HTTP or SOAP request to an external server. You can simply \r\ncall this external resource from a different thread, and complete the response when you get the result.\r\n\r\nTo tell the server that you're ready to serve the response, call the <code>done</code> method on the response.\r\n\r\nLook at the [Asynchronous example](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/async/AsyncExample.java)\r\nto see how to serve content from a separate thread.\r\n\r\n\r\n## Routing\r\n\r\nMost modern webapps have nice URLs. Simple URLs are also easier to remember and more user friendly. \r\n\r\nMolecule comes with a routing middleware that let you define your URL routes. \r\n\r\nRoutes let you map incoming requests to different applications based on the request verb and path. A route is composed\r\nof a path pattern, an optional set of verbs to match, and an application endpoint: \r\n\r\n```java\r\nserver.start(new DynamicRoutes() {{\r\n    get(\"/posts/:id\").to((request, response) -> {\r\n        // retrieve a given post\r\n    });\r\n    post(\"/posts\").to((request, response) -> {\r\n        // create a new post\r\n    }); \r\n    put(\"/posts/:id\").to((request, response) -> {\r\n        // update an existing post\r\n    });\r\n    delete(\"/posts/:id\").to((request, response) -> {\r\n        // delete a post\r\n    }); \r\n    map(\"/\").to((request, response) -> {\r\n        // show the home page\r\n    });\r\n}});\r\n```\r\n### Matching\r\n\r\nRoutes are matched in the order they are defined. If not defined route matches, the default behaviour is to \r\nrender a 404 Not Found. This can be configured to pass the control to any default application.\r\n\r\nBy default, a route matches a single verb, specified by the method you use, i.e. _get_, _post_, _put_, _delete_.\r\nThat can be changed by providing the verbs as arguments to the _via_ method:\r\n\r\n```java\r\nmap(\"/\").via(GET, HEAD).to((request, response) -> {\r\n    // show the home page\r\n});\r\n```\r\n\r\nIf you don't provide any verbs, _map_ will match on all verbs.\r\n\r\n### Dynamic Parameters\r\n\r\nRoute patterns can be matched exactly - they are said to be static - or can include named parameters,\r\n which are then accessible as regular request parameters on the request object:\r\n\r\n```java\r\n// matches \"GET /photos/18\" and \"GET /photos/25\"\r\n// request.parameter(\"id\") is either '18' or '25'\r\nget(\"/photos/:id\").to((request, response) -> {\r\n    response.done(\"Photo #\" + request.parameter(\"id\"));\r\n});\r\n```\r\n\r\n### Custom Matching\r\n\r\nYou are not limited to the provided match patterns. You can easily implement your own matcher and decide exactly how to match an incoming url to an application.\r\n\r\nTo do this, use the route definition methods that accept a _Matcher_ rather than a _String_.\r\n\r\n\r\n## Working with the Request\r\n\r\nApplications receive a <code>Request</code> that provide information about the request coming in from the client.\r\n\r\nThe request represents the environment for the client request, including the headers, the request body as well as parameters and other common things. The <code>Request</code> object is built from information provided by the HTTP server. \r\n\r\nAny middleware can modify the content of the request during processing before passing control to the next stage of the middleware pipeline. This of course has no effect on the original HTTP request. See [Middlewares](#middlewares) for more information on middlewares and the middleware pipeline.\r\n\r\n### Request\r\n\r\n```java\r\nrequest.uri();                          // the uri, e.g. /path?query\r\nrequest.path();                         // the path info, e.g. /foo\r\nrequest.remoteIp();                     // ip of the client\r\nrequest.remoteHost();                   // hostname of the client\r\nrequest.remotePort();                   // port of the client\r\nrequest.protocol();                     // protocol, e.g. HTTP or HTTPS\r\nrequest.timestamp();                    // time the request came in\r\nrequest.secure();                       // whether the request was made over a secure connection\r\nrequest.method();                       // HTTP method (e.g.  GET, POST, PUT, etc.)\r\nrequest.body();                         // the body as a string, decoded using the request charset\r\nrequest.bodyContent();                  // the raw body content as bytes\r\nrequest.bodyStream();                   // the body as a stream of bytes\r\nrequest.parts();                        // list of parts of a multipart/form-data request\r\nrequest.part(\"name\");                   // named part of a multipart/form-data request\r\nrequest.charset();                      // charset of the body, read from the content type\r\nrequest.hasHeader(\"name\");              // checks presence of a named header\r\nrequest.header(\"name\");                 // value of a given HTTP header\r\nrequest.headers(\"name\");                // list of values of a given HTTP header\r\nrequest.headerNames();                  // the set of HTTP header names received\r\nrequest.contentLength();                // length of the body\r\nrequest.contentType();                  // content type of the body\r\nrequest.hasParameter(\"name\")            // checks for the presence of a request parameter\r\nrequest.parameter(\"name\");              // value of a specific request parameter\r\nrequest.paremeters(\"name\");             // list of values for a specific request parameter\r\nrequest.parameterNames();               // set of all request parameter names\r\nrequest.allParameters();                // map of all request parameters\r\nrequest.attribute(\"key\");               // value of a keyed attribute\r\nrequest.attribute(\"key\", \"value\");      // sets the value of a keyed attribute\r\nrequest.attributeKeys();                // set of all attibute keys\r\nrequest.removeAttribute(\"key\");         // removes a keyed attribute\r\nrequest.attributes();                   // map of all request attributes\r\n```\r\n\r\nFor the complete documentation, see the Javadoc of the <code>Request</code> class.\r\n\r\n### Attributes\r\n\r\nRequest attributes are not sent by the client - as opposed to request parameters. They are used for server-side processing only.\r\n\r\nAttributes are a local server storage mechanism, scoped within the request. Whereas request parameters are string literals, request attributes can be any type of <code>Object</code>s.\r\n\r\n## Working with the Response\r\n\r\nApplications respond to client requests by sending data back to the client using the <code>Response</code>. \r\n\r\nThe response includes a status code and text, headers and an optional body. \r\n\r\nAny middleware can modify the content of the response during processing before returning control to the previous stage of the middleware pipeline. See [Middlewares](#middlewares) for more information on middlewares and the middleware pipeline.\r\n\r\n### Response\r\n\r\n```java\r\nresponse.status(HttpStatus.OK);         // sets the status\r\nresponse.statusCode(400);               // sets the status code\r\nresponse.statusText(\"Bad Request\");     // sets the status text\r\nresponse.redirect(\"/url\");              // 303 redirect to /url\r\nresponse.header(\"name\", \"value\");       // sets the single value of a named header\r\nresponse.addHeader(\"name\", \"value\");    // adds another value to a named header\r\nresponse.contentType(\"text/html\");      // sets the Content-Type header of the response\r\nresponse.contentLength(16384);          // sets the Content-Length header of the response\r\nresponse.charset(\"utf-8\");              // sets the charset of the response body\r\nresponse.body(\"text\");                  // sets the response body as text\r\nresponse.done();                        // sends the response to the client\r\nresponse.done(\"text\");                  // sends the specified response text to the client\r\n```\r\nFor the complete documentation, see the Javadoc of the <code>Response</code> class.\r\n\r\nNote that no response will actually be sent back to the client until the <code>done</code> method is called.\r\nCalling <code>done</code> signals the end of the request processing and triggers sending back the status, \r\nheaders and body.\r\n\r\n### Rendering\r\n\r\nThere are a variety of ways to send back a response to the client. You can render text, binary content, \r\nthe content of a file, XML, JSON, use a view template or render nothing at all. You can specify the content type or HTTP status of the rendered response as well.\r\n\r\nMolecule uses the concept of response <code>Body</code> to represent data to send back to the client.\r\n\r\nMolecule comes with a few body implementations ready to use for sending text, binary content, the content of a file or\r\n a view template.\r\n \r\n\r\n#### Rendering an empty response\r\n\r\nYou can render an empty response by not specifying a body at all. In which case, an empty body is used. \r\n\r\nSo this is perfectly valid:\r\n\r\n```java\r\nresponse.done();\r\n```\r\n\r\n#### Rendering text\r\n\r\nYou can send plain text - with no markup at all - back to the browser like this:\r\n\r\n```java\r\nresponse.done(\"All good\");\r\n```\r\n\r\nRendering pure text is sometimes useful if you're client is expecting something other than proper HTML.\r\n                         \r\n#### Rendering HTML\r\n                         \r\nYou can send an HTML string back to the browser by using a text body to render:\r\n                         \r\n```java\r\nresponse.done(\"<html><body><h1>It Works</h1></body></html>\");\r\n```\r\n\r\nThis can be useful when you're rendering a small snippet of HTML code. However, you might want to consider moving it to a template file if the markup is complex. See [View Templating](#view-templates) for more on using templates. \r\n                       \r\n                       \r\n#### Rendering JSON\r\n\r\nYou can send back JSON to the browser by using a text body. Here's an example using google Gson library:\r\n \r\n```java\r\nGson gson = new Gson();\r\nresponse.done(gson.toJSON(\"ok\"));\r\n``` \r\n\r\nAnother option would be to create a your own body implementation - let's call it <code>JSONBody</code> - \r\nand use your preferred JSON serializer:\r\n \r\n```java\r\nresponse.done(new JSONBody(\"ok\"));\r\n```\r\n\r\nor with a static factory method:\r\n\r\n```java\r\nresponse.done(json(\"ok\"));\r\n```\r\n\r\nRendering XML can be done the same way.\r\n\r\n\r\n#### Rendering binary content\r\n\r\nYou can send back a raw body as binary like this:\r\n\r\n```java\r\nbyte[] content = ... //\r\nresponse.body(content).done();\r\n```\r\n\r\n#### Rendering the content of a file\r\n\r\nYou can use a <code>FileBody</code> to stream the content of a file:\r\n \r\n ```java\r\n response.render(new FileBody(new File(\"/path/to/file\")))).done();\r\n ```\r\n \r\n This will use a default chunk size of <code>8K</code>, although you can specify a different chunk size.\r\n\r\n#### Redirection\r\n\r\nYou can trigger a browser redirect using a See Other (303) status code \r\nusing the <code>redirectTo</code> method on the <code>Response</code>:\r\n\r\n```java\r\nresponse.redirectTo(\"/url\").done();\r\n```\r\n\r\nIf you need to use a different status code, simply change the status: \r\n\r\n```java\r\nresponse.redirectTo(\"/url\").statusCode(301).done(); // moved permanently\r\n```\r\n\r\n## Cookies\r\n\r\nTo enable cookies support first add the <code>Cookies</code> middleware to your middleware pipeline (see [Middlewares](#middlewares) for more information on using middlewares).\r\n\r\nThis will create a <code>CookieJar</code> and populate that cookie jar with cookies sent by the client. The cookie jar is available as a request attribute:\r\n\r\n```java\r\nCookieJar cookies = CookieJar.get(request);\r\n```\r\n\r\nTo read cookies sent by the client:\r\n```java\r\nCookie customer = cookies.get(\"customer\");\r\n```\r\n\r\nTo send back cookies to the client, all you have to do is add cookies to the jar:\r\n```java\r\ncookies.add(\"weapon\", \"rocket launcher\")\r\n       .path(\"/ammo\")\r\n       .maxAge(30)\r\n```\r\n\r\nTo expire a cookie, discard it from the jar:\r\n```java\r\ncookies.discard(\"weapon\").path(\"/ammo\");\r\n```\r\n\r\nFor more on cookies, see the [Cookies example](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/cookies/CookiesExample.java).\r\n\r\n## Sessions\r\n\r\n### Enabling sessions support\r\n\r\nTo use sessions you need to start your server with session support:\r\n\r\n```java\r\nserver.add(new Cookies())\r\n      .add(new CookieSessionTracker(CookieSessionStore.secure(\"your secret\");))\r\n      .start(new DynamicRoutes() {{\r\n      // your routing here\r\n}}\r\n```\r\n\r\nSince HTTP is a stateless protocol and Molecule uses a minimalist approach, sessions are not part of the request. \r\nUsage of sessions requires the use of a middleware. This means you have full control over the way sessions are tracked and stored.\r\n\r\nMolecule comes with a <code>CookieSessionTracker</code> middleware that uses cookies to track sessions across HTTP requests and two session storage mechanisms:\r\n* An in memory session store, the <code>SessionPool</code>\r\n* A client side storage using encrypted cookies, the <code>CookieSessionStore</code> \r\n\r\n### Using sessions\r\n\r\nOnce session support is enabled, the current session is bound to the request:\r\n\r\n```java\r\nSession session = Session.get(request);\r\n```\r\n\r\nOne thing to understand is that as long as your server is started with session support, there will *always* be a session bound to the request. There's no need to check against <code>null</code>. There's no need to ask for session creation either. \r\n\r\nThe session attached to the request can be a fresh and empty session or the session opened in a previous request. This does not mean a new session is automatically opened for each request though. A fresh session is only persisted if it is modified before the end of the request cycle. This means you can safely read from a new session. \r\n\r\nIf you write data to the session then it is automatically persisted to the session store you've selected - created in case of a new session or updated in case of an existing session. If you invalidate the session, it will be discarded from the session store automatically.\r\n\r\nSome of the things you can do with sessions include:\r\n```\r\nsession.fresh()             // checks if session is new\r\nsession.id()                // gets the session id\r\nsession.createdAt()         // the session creation time\r\nsession.updatedAd()         // the last session update time\r\nsession.expires()           // whether this session expires\r\nsession.expirationTime()    // this session expiration time, if it expires\r\nsession.maxAge(30)          // sets the session to expire after 30s of inactivity\r\nsession.contains(\"key\")     // checks if this session contains a keyed attribute\r\nsession.get(\"key\")          // returns the keyed attribute\r\nsession.remove(\"key\")       // removes a keyed attribute\r\nsession.put(\"key\", \"value\") // writes a key value pair to the session\r\nsession.clear()             // clears the session content\r\nsession.invalidate()        // invalidates the session\r\n```\r\n\r\nFor more on using sessions, see the [Session Example](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/session/SessionExample.java).\r\n\r\n## View Templates\r\n\r\nWhen your markup becomes complex, you might want to consider moving it to a template file.\r\n\r\nRendering a template requires a <code>RenderingEngine</code>. To use the built-in <code>JMustacheRenderer</code>, first\r\n  add [JMustache](https://github.com/samskivert/jmustache) to your dependencies:\r\n  \r\n```xml\r\n<dependency>\r\n    <groupId>com.samskivert</groupId>\r\n    <artifactId>jmustache</artifactId>\r\n    <version>1.13</version>\r\n</dependency>\r\n```\r\n\r\nRendering a template takes a view model and returns a body object to use with the response. Assuming\r\n a Mustache template file named <i>profile.mustache</i>, here's how we would render the template \r\n using an hypothetical <code>Employee</code> object: \r\n  \r\n```java\r\n// Declare the template engine\r\nTemplates templates = new Templates(new JMustacheRenderer().fromDir(new File(\"/path/to/template/files\")));\r\n// Load the 'profile.mustache' template\r\nTemplate<Employee> profile = templates.named(\"profile\");\r\n// Render the template using an Employee instance \r\nresponse.done(profile.render(new Employee(\"Bob\", \"...\")));\r\n```  \r\n  \r\nFor further information on using view templates, take a look at the [View Templates and Layout example](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/templating/TemplatingAndLayoutExample.java).\r\n \r\n## View Layouts\r\n\r\nSometimes you want to share a common look and feel for a set of pages. This is when view layouts can help.\r\n \r\nLayouts are just templates that are used to decorate existing pages. A layout defines the surroundings of your HTML page. \r\nIt's where you define a common look and feel of your final output. This reverses the common pattern of \r\nincluding shared headers and footers in many templates to isolate changes in repeated setups.\r\n\r\nThink of the layout rendering process in two steps. \r\n\r\nThe first step processes the generated HTML view to extract its content. \r\nThis extraction process makes individual pieces of the original page content available to the layout template:\r\n\r\n* the head content, excluding the title\r\n* the title\r\n* the body content\r\n* all the meta parameters\r\n\r\nThe second step merges the content pieces with the layout template to produce the final\r\nresult. \r\n\r\nHere's a contrived example of a mustache layout template that simply recreates the original page:\r\n\r\n```html\r\n<html>\r\n<head>\r\n{{head}}\r\n<title>{{title}}</title>\r\n</head>\r\n<body>\r\n{{body}}\r\n</body>\r\n</html>\r\n```\r\n  \r\nThe <code>Layout</code> middleware intercepts generated HTML responses and merges them with layout decorator(s) \r\nto build the final result:\r\n\r\n```java\r\n// Declare the template engine\r\nTemplates layouts = new Templates(new JMustacheRenderer().fromDir(new File(\"/path/to/layout/templates\")));\r\n// Load the main layout template\r\nTemplate<Map<String, String>> mainLayout = layouts.named(\"main\");\r\n\r\n// Apply the main site layout to requests under the / path, in other words to all rendered pages\r\nserver.filter(\"/\", Layout.html(mainLayout))\r\n      .start(new DynamicRoutes() {{\r\n          // Your routes definitions here\r\n          // ...\r\n      }});\r\n\r\n``` \r\n\r\nFor more on using layouts, take a look at the [View Templates and Layout example](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/templating/TemplatingAndLayoutExample.java).\r\n\r\n## SSL\r\n\r\nTo use HTTPS connections, enable SSL on the <code>WebServer</code>. Enabling HTTPS/SSL requires you to have a keystore file, which you can generate using the Java `keytool`. You specify the location of your keystore, the keystore password \r\nand the keys password like this:\r\n\r\n```java\r\nWebServer server = WebServer.create();\r\nserver.enableSSL(new File(\"/path/to/keystore/file\"), \"keyStorePassword\", \"keyPassword\"))\r\n      .start(...);\r\n```\r\n\r\nThis will start the server with TLS enabled, trusting all clients.\r\n\r\nIf you need more control over the type of keystore and algorithms used, you can alternatively pass \r\nan <code>javax.net.ssl.SSLContext</code> to use.\r\n\r\nSee the [SSL example](https://github.com/testinfected/molecule/blob/master/src/test/java/examples/ssl/SSLExample.java) \r\nfor more details.\r\n\r\n## Testing\r\n\r\n## Middlewares\r\n\r\nMiddlewares are a way to enhance your application with optional building blocks, using a pipeline design. A middleware component sits between the client and the server, processing inbound requests and outbound responses.\r\n\r\nMiddlewares implement functionality you tend to need across all your applications,\r\nbut you don't want to build everytime. Things like **access logging**, **authentication**, \r\n**compression**, **static files**, **routing**, etc.\r\n\r\nBeing able to separate the processing of the request (and post-processing of the response) in different stages \r\nhas several benefits:\r\n\r\n* It separate concerns, which helps keep your design clean and application well-structured\r\n* It let you only include the functionality you need, so your server is as small and fast as possible \r\n* It let you plug in your own processing stages, to customize the behavior of your application\r\n* It let you reuse and share middlewares, as elemental building blocks of application behavior\r\n\r\nFor example you could have the following separate stages of the pipeline doing:\r\n\r\n1. Capturing internal server errors to render a nice 500 page\r\n1. Monitoring, logging accesses to the server\r\n1. Authentication and authorisation, to control access to your applicatoin\r\n1. Caching, returning a cached result if request has already been processed recently\r\n1. Compression, to reduce bandwith usage\r\n1. Security, to prevent attacks such as CSRF\r\n1. Processing, the actual request processing by your application\r\n \r\n### The Middleware Stack\r\n\r\nYou can think of the Middleware pipeline as a stack, at the bottom of which is your application. When a request comes in, it starts at the top of the stack and goes down until it is processed by your application. The response then goes up the stack backwards through the middleware chain, before it is sent back to the client. \r\n\r\nWe call it a middleware stack because each part will call the next part in sequence. Or it might not. In fact there are two types of middlewares. Those that modify the request or response and call the next step in the chain, and those that short circuit the stack and return their own response without ever calling anything further down the stack.\r\n\r\n\r\n### Building the Middleware Stack\r\n\r\nThe simplest way to build your middleware stack is to add middlewares to your WebServer. \r\n\r\nFor example, suppose we'd like to enhance performance of our application by adding caching and compression:\r\n\r\n```java\r\nWebServer server = WebServer.create();\r\nserver.add(new ContentLengthHeader())\r\n      .add(new ConditionalGet())\r\n      .add(new ETag())\r\n      .add(new Compressor())\r\n      .start(new DynamicRoutes() {{\r\n          // ...\r\n      }});\r\n```\r\n\r\nHere's what a more complete, real-life middleware stack might look like:\r\n```java\r\nserver.failureReporter(failureReporter)\r\n      .add(new ServerHeader(\"Simple/6.0.1\"))\r\n      .add(new DateHeader())\r\n      .add(new ApacheCommonLogger(logger))\r\n      // a custom middleware to redirect non secure requests to HTTPS \r\n      .add(new ForceSSL())\r\n      .add(new ContentLengthHeader())\r\n      .mount(\"/api\", new MiddlewareStack() {{\r\n          use(new Failsafe());\r\n          use(new FailureMonitor(failureReporter));\r\n          use(new ConnectionScope(database));\r\n          // runs the api application\r\n          run(api());\r\n      }})\r\n      .add(new ConditionalGet())\r\n      .add(new ETag())\r\n      .add(new Compressor().compressibleTypes(CSS, HTML))\r\n      // configures the StaticAssets middleware\r\n      .add(staticAssets())\r\n      .add(new HttpMethodOverride())\r\n      .add(new Cookies())\r\n      // a custom middleware to redirect based on the preferred user locale\r\n      .add(selectLocale())\r\n      // a custom middleware to display static pages if case of errors\r\n      .add(new PublicExceptions())\r\n      .add(new Failsafe())\r\n      .add(new FailureMonitor(failureReporter))\r\n      .add(new ConnectionScope(dataSource))\r\n      .add(new CookieSessionTracker(CookieSessionStore.secure(\"secret\")))\r\n      .add(new Flash())\r\n      // starts the main application\r\n      .start(webapp());\r\n```\r\n\r\nFor more on using middlewares, take a look at the various code examples (see above), \r\nincluding the [sample application](https://github.com/testinfected/simple-petstore/blob/master/webapp/src/main/java/org/testinfected/petstore/PetStore.java).\r\n\r\nThe javadoc of the <code>WebServer</code> class is another good source of information. \r\n\r\n\r\n### Available Middlewares\r\n\r\nMolecule comes with a bunch of handy middlewares that you can use to build your processing pipeline:\r\n\r\n* Router (See [Routing](#routing))\r\n* Static Assets \r\n* File Server\r\n* Apache Common Logger\r\n* Apache Combined Logger\r\n* Cookies (See [Cookies](#cookies))\r\n* Locale Negotiation\r\n* Compressor\r\n* ETag\r\n* Conditional Get\r\n* Connection Scope\r\n* Server Header\r\n* Date Header\r\n* Content-Length Header\r\n* Filter Map\r\n* URL Map\r\n* Cookie Session Tracker\r\n* Failsafe\r\n* Failure Monitor\r\n* Not Found\r\n* Http Method Override\r\n* Layout\r\n* Flash\r\n\r\n\r\n## Living on the edge\r\n\r\n\r\nIf you want the latest development version, grab the latest snapshot from [Sonatype snapshots repositories]:\r\n\r\n```xml\r\n<dependency>\r\n      <groupId>com.vtence.molecule</groupId>\r\n      <artifactId>molecule</artifactId>\r\n      <version>0.11-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n\r\nNew snapshots are pushed to Sonatype on every commit. So you'll always be running the head version. \r\n\r\n[Sonatype snapshots repositories]: https://oss.sonatype.org/content/repositories/snapshots\r\n",
  "google": "UA-16545808-2",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}